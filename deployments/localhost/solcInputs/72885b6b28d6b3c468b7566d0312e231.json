{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC721Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC721Metadata} from \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport \"./interfaces/IERC721Enumerable.sol\";\nimport \"./libraries/DiamondLib.sol\";\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { DiamondLib } from \"./libraries/DiamondLib.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { DiamondSettings } from \"./interfaces/IDiamond.sol\";\nimport { IERC173 } from \"./interfaces/IERC173.sol\";\n\n/**\n * @title Diamond\n * @dev Core diamond proxy contract implementing the EIP-2535 Diamond Standard\n * Functionality has been separated into facets:\n * - DiamondCutFacet: Handles diamond cut operations\n * - DiamondLoupeFacet: Provides introspection functions\n * - OwnershipFacet: Handles ownership operations\n */\ncontract Diamond is Initializable, IERC173 {\n    /**\n     * @notice Initialize the Diamond contract\n     * @param _owner The owner of the contract\n     * @param params Diamond settings including name and symbol\n     * @param _facets The initial facets to add\n     * @param diamondInit The initialization contract\n     * @param _calldata The initialization calldata\n     */\n    function initialize(\n        address _owner,\n        DiamondSettings memory params,\n        IDiamondCut.FacetCut[] calldata _facets,\n        address diamondInit,\n        bytes calldata _calldata\n    ) public initializer {\n        // Set up interfaces\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC165).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC173).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721Metadata).interfaceId] = true;\n        LibDiamond.diamondStorage().supportedInterfaces[type(IERC721Enumerable).interfaceId] = true;\n\n        // Initialize the diamond\n        LibDiamond.diamondCut(_facets, diamondInit, _calldata);\n\n        // Set the owner\n        LibDiamond.setContractOwner(_owner);\n\n        // Set the symbol and name of the diamond\n        DiamondLib.diamondStorage().diamondContract.settings.owner = _owner;\n        DiamondLib.diamondStorage().diamondContract.metadata['symbol'] = params.symbol;\n        DiamondLib.diamondStorage().diamondContract.metadata['name'] = params.name;\n\n        // Initialize the upgrade timelock\n        LibDiamond.initializeUpgradeTimelock(LibDiamond.DEFAULT_UPGRADE_TIMELOCK);\n    }\n\n    /**\n     * @notice Transfer ownership to a new address\n     * @param _newOwner The new owner address\n     */\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    /**\n     * @notice Get the current contract owner\n     * @return owner_ The current owner address\n     */\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    /**\n     * @notice Get this contract's address\n     * @return This contract's address\n     */\n    function diamondAddress() external view returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev Diamond Proxy fallback function\n     * Find facet for function that is called and execute the\n     * function using delegatecall\n     */\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // Get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // Get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        \n        // Execute external function from facet using delegatecall and return any value\n        assembly {\n            // Copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // Execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // Get any return value\n            returndatacopy(0, 0, returndatasize())\n            // Return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    // Allow contract to receive ETH\n    receive() external payable {}\n}\n"
    },
    "contracts/facets/CounterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n/**\n * @title CounterFacet\n * @dev A sample facet that demonstrates basic diamond functionality with a simple counter\n *      This facet provides increment, decrement, and view operations for a counter value\n *      stored in diamond storage. It serves as an example of how to implement business\n *      logic in a diamond facet while using the diamond storage pattern.\n */\ncontract CounterFacet {\n    // Custom storage struct for this facet\n    struct CounterStorage {\n        uint256 counter;\n        address lastUpdater;\n        uint256 lastUpdateTimestamp;\n        mapping(address => uint256) userCounters;\n    }\n\n    // Storage position for this facet\n    bytes32 constant COUNTER_STORAGE_POSITION = keccak256(\"counter.facet.storage\");\n\n    // Events\n    event CounterIncremented(address indexed user, uint256 newValue);\n    event CounterDecremented(address indexed user, uint256 newValue);\n    event CounterReset(address indexed user, uint256 previousValue);\n    event UserCounterUpdated(address indexed user, uint256 newValue);\n\n    /**\n     * @notice Get the counter storage\n     * @dev Internal function to access the counter's diamond storage slot\n     * @return cs The counter storage struct\n     */\n    function counterStorage() internal pure returns (CounterStorage storage cs) {\n        bytes32 position = COUNTER_STORAGE_POSITION;\n        assembly {\n            cs.slot := position\n        }\n    }\n\n    /**\n     * @notice Increment the global counter by 1\n     * @dev Increases the global counter and updates metadata\n     */\n    function increment() external {\n        CounterStorage storage cs = counterStorage();\n        cs.counter += 1;\n        cs.lastUpdater = msg.sender;\n        cs.lastUpdateTimestamp = block.timestamp;\n        \n        emit CounterIncremented(msg.sender, cs.counter);\n    }\n\n    /**\n     * @notice Decrement the global counter by 1\n     * @dev Decreases the global counter and updates metadata\n     *      Reverts if counter would go below zero\n     */\n    function decrement() external {\n        CounterStorage storage cs = counterStorage();\n        require(cs.counter > 0, \"CounterFacet: Counter cannot go below zero\");\n        \n        cs.counter -= 1;\n        cs.lastUpdater = msg.sender;\n        cs.lastUpdateTimestamp = block.timestamp;\n        \n        emit CounterDecremented(msg.sender, cs.counter);\n    }\n\n    /**\n     * @notice Reset the global counter to zero\n     * @dev Only the diamond owner can reset the counter\n     */\n    function resetCounter() external {\n        LibDiamond.enforceIsContractOwner();\n        CounterStorage storage cs = counterStorage();\n        \n        uint256 previousValue = cs.counter;\n        cs.counter = 0;\n        cs.lastUpdater = msg.sender;\n        cs.lastUpdateTimestamp = block.timestamp;\n        \n        emit CounterReset(msg.sender, previousValue);\n    }\n\n    /**\n     * @notice Get the current global counter value\n     * @return The current counter value\n     */\n    function getCounter() external view returns (uint256) {\n        return counterStorage().counter;\n    }\n\n    /**\n     * @notice Get metadata about the last counter update\n     * @return lastUpdater Address of the last user to update the counter\n     * @return lastUpdateTimestamp Timestamp of the last update\n     */\n    function getCounterMetadata() external view returns (address lastUpdater, uint256 lastUpdateTimestamp) {\n        CounterStorage storage cs = counterStorage();\n        return (cs.lastUpdater, cs.lastUpdateTimestamp);\n    }\n\n    /**\n     * @notice Increment a user's personal counter\n     * @dev Each user has their own counter independent of the global one\n     */\n    function incrementUserCounter() external {\n        CounterStorage storage cs = counterStorage();\n        cs.userCounters[msg.sender] += 1;\n        \n        emit UserCounterUpdated(msg.sender, cs.userCounters[msg.sender]);\n    }\n\n    /**\n     * @notice Get a user's personal counter value\n     * @param user The address of the user\n     * @return The user's counter value\n     */\n    function getUserCounter(address user) external view returns (uint256) {\n        return counterStorage().userCounters[user];\n    }\n\n    /**\n     * @notice Set a user's counter to a specific value\n     * @dev Only the user themselves or the diamond owner can set their counter\n     * @param value The new counter value\n     */\n    function setUserCounter(uint256 value) external {\n        CounterStorage storage cs = counterStorage();\n        cs.userCounters[msg.sender] = value;\n        \n        emit UserCounterUpdated(msg.sender, value);\n    }\n\n    /**\n     * @notice Set any user's counter (owner only)\n     * @dev Only the diamond owner can set other users' counters\n     * @param user The user whose counter to set\n     * @param value The new counter value\n     */\n    function setUserCounterAsOwner(address user, uint256 value) external {\n        LibDiamond.enforceIsContractOwner();\n        CounterStorage storage cs = counterStorage();\n        cs.userCounters[user] = value;\n        \n        emit UserCounterUpdated(user, value);\n    }\n}"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of the diamond cut functions.\n/******************************************************************************/\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title DiamondCutFacet\n * @dev Implementation of the diamond cut functionality with a timelock mechanism.\n *      The diamond cut operation allows adding, replacing, or removing facets and functions\n *      from the diamond proxy contract. This implementation adds a security timelock\n *      that requires a two-step process (propose and execute) for diamond cuts,\n *      enhancing security by allowing time for review before execution.\n *      Based on the EIP-2535 Diamond Standard.\n */\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Propose a diamond cut to be executed after the timelock period\n    /// @dev First step in the two-step process for modifying the diamond. This queues up\n    ///      changes that can only be executed after a predefined timelock period.\n    ///      Only the contract owner can propose changes.\n    /// @param _diamondCut Contains the facet addresses and function selectors to add, replace, or remove\n    /// @param _init The address of the contract or facet to execute initialization code\n    /// @param _calldata A function call, including function selector and arguments, for initialization\n    function proposeDiamondCut(\n        IDiamondCut.FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.proposeDiamondCut(_diamondCut, _init, _calldata);\n    }\n    \n    /// @notice Execute a previously proposed diamond cut after the timelock period has elapsed\n    /// @dev Second and final step in the two-step diamond modification process.\n    ///      This executes the changes that were previously proposed, but only if\n    ///      the required timelock period has passed. The timelock period is a\n    ///      security measure to allow stakeholders time to review proposed changes.\n    ///      Only the contract owner can execute the diamond cut.\n    /// @custom:security Reverts if no diamond cut is proposed, if the timelock period\n    ///                  hasn't expired, or if the initialization call fails\n    function executeDiamondCut() external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.executeDiamondCut();\n    }\n    \n    /// @notice Cancel a previously proposed diamond cut\n    /// @dev Allows the contract owner to cancel a pending diamond cut proposal\n    ///      before it is executed. This is useful if errors are found in the\n    ///      proposed changes during the timelock period or if the changes\n    ///      are no longer desired. Once cancelled, the proposal is completely\n    ///      removed and a new proposal would need to be submitted if needed.\n    /// @custom:security Only callable by the contract owner\n    function cancelDiamondCut() external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.cancelDiamondCut();\n    }\n    \n    /// @notice Add/replace/remove any number of functions and optionally execute initialization code\n    /// @dev THIS FUNCTION IS DEPRECATED and will always revert when called.\n    ///      It has been replaced by the more secure two-step process using\n    ///      proposeDiamondCut() followed by executeDiamondCut(), which adds a timelock\n    ///      security feature. This function remains to maintain compatibility with\n    ///      the IDiamondCut interface but cannot be used.\n    /// @custom:security Always reverts with an error message directing to the new functions\n    function diamondCut(\n        IDiamondCut.FacetCut[] calldata,\n        address,\n        bytes calldata\n    ) external pure override {\n        revert(\"Function deprecated: Use proposeDiamondCut() + executeDiamondCut() instead\");\n    }\n}"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of the diamond loupe functions.\n/******************************************************************************/\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title DiamondLoupeFacet\n * @dev Implementation of the DiamondLoupe standard which provides introspection functions\n *      to view what facets and functions are available in the diamond contract.\n *      The Diamond Loupe functions make it possible to look up facets and functions\n *      implemented by a diamond. This implementation is based on the EIP-2535 Diamond Standard.\n */\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    /// @notice Gets all facets and their selectors that are registered with the diamond\n    /// @dev This function is used to inspect the full facet structure of the diamond\n    /// @return facets_ An array of Facet structs containing the facet addresses and\n    ///         their associated function selectors\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet\n    /// @dev Used to retrieve all function selectors managed by a single facet implementation\n    /// @param _facet The facet address to query\n    /// @return facetFunctionSelectors_ Array of function selectors (bytes4) supported by the facet\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory facetFunctionSelectors_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses registered in the diamond\n    /// @dev Provides a complete list of implementation contracts that make up the diamond's functionality\n    /// @return facetAddresses_ Array of all registered facet addresses\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet address that implements a specific function\n    /// @dev Used to determine which implementation contract handles a particular function.\n    ///      This function is critical for understanding the diamond's current function routing.\n    ///      If no facet is found for the selector, returns address(0).\n    /// @param _functionSelector The 4-byte function selector to find the implementation for\n    /// @return facetAddress_ The facet address implementing the function, or address(0) if not found\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n\n    /// @notice Checks if the contract implements an interface\n    /// @dev ERC-165 implementation that checks if the diamond supports a specific interface.\n    ///      Returns true for IDiamondLoupe and IERC165 interfaces, and any additional\n    ///      interfaces registered with the diamond.\n    /// @param _interfaceId The interface identifier to check, as specified in ERC-165\n    /// @return True if the contract implements the interface, false otherwise\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return _interfaceId == type(IERC165).interfaceId || \n               _interfaceId == type(IDiamondLoupe).interfaceId ||\n               ds.supportedInterfaces[_interfaceId];\n    }\n}"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title OwnershipFacet\n * @dev Implementation of the ERC-173 ownership standard for the Diamond proxy pattern.\n *      This facet manages the ownership of the diamond contract, which is a critical\n *      security consideration as the owner has complete control over the contract's\n *      functionality through diamond cuts. The ownership model follows the standard\n *      single-owner pattern where the owner can transfer ownership to another address.\n *      This facet implements both the IERC173 interface for ownership and the IERC165\n *      interface for standard interface detection.\n */\nabstract contract OwnershipFacet is IERC173, IERC165 {\n    /**\n     * @notice Transfer ownership of the contract to a new address\n     * @dev Only the current owner can call this function. This is a critical\n     *      security function as the owner has complete control over the diamond.\n     *      The ownership transfer happens immediately with no two-step process,\n     *      so extreme care should be taken to ensure the new owner address is correct.\n     *      Setting the owner to address(0) will effectively renounce ownership,\n     *      leaving the contract without an owner and unable to perform privileged\n     *      operations like diamond cuts.\n     * @param _newOwner The address of the new owner\n     */\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    /**\n     * @notice Get the current contract owner's address\n     * @dev This view function returns the address of the current owner\n     *      without making any state changes. The owner is stored in the\n     *      diamond storage pattern and retrieved through the LibDiamond library.\n     *      The owner has exclusive privileges for critical operations including\n     *      diamond cuts and transferring ownership.\n     * @return owner_ The current owner address\n     */\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n\n    // Removed supportsInterface(bytes4) function.\n    // This should be handled by DiamondLoupeFacet (ERC165).\n}"
    },
    "contracts/interfaces/IDiamond.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n\nstruct DiamondSettings {\n  address owner;\n  address factory;\n  address svgManager;\n  string symbol;\n  string name;\n}\n\nstruct DiamondContract {\n  DiamondSettings settings;\n  mapping(string=>string) metadata;\n}\n\nstruct DiamondStorage {\n  DiamondContract diamondContract;\n}\n\n\ninterface IDiamond {\n  function getDiamondAddress() external view returns (address);\n}\n\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n    \r\n    /// @notice Propose an upgrade to be executed after the timelock period\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    function proposeDiamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n    \r\n    /// @notice Execute a previously proposed upgrade after the timelock period\r\n    function executeDiamondCut() external;\r\n    \r\n    /// @notice Cancel a proposed upgrade\r\n    function cancelDiamondCut() external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n    event DiamondCutProposed(address indexed proposer, uint256 indexed proposalTime, uint256 executionTime);\r\n    event DiamondCutCancelled(address indexed canceller);\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondFacetInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./IDiamondCut.sol\";\nimport \"./IERC165.sol\";\n\ninterface IDiamondFacetInit is IERC165 {\n    function initializeFacet(\n        address _owner, \n        IDiamondCut.FacetCut memory _facet,\n        bytes calldata _calldata) external;\n}\n"
    },
    "contracts/interfaces/IDiamondFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport { IDiamondCut } from \"./IDiamondCut.sol\";\n\nstruct DiamondFactoryInit {\n    string setName;\n    IDiamondCut.FacetCut[] facetAddresses;\n    bytes diamondBytecode;\n}\n\nstruct DiamondFactoryContract {\n    string[] diamondSymbols;\n    mapping(string => address) diamondAddresses;\n    mapping(string => IDiamondCut.FacetCut[]) facetsToAdd;\n    string[] facetSets;\n    string defaultFacetSet;\n    address diamondInit_;\n    bytes calldata_;\n}\n"
    },
    "contracts/interfaces/IDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./IDiamondCut.sol\";\n\ninterface IDiamondInit {\n    function initialize(\n        address _owner, \n        IDiamondCut.FacetCut[] memory _facets,\n        address _init,\n        bytes calldata _calldata) external;\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nstruct ERC721EnumerableContract {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) _allTokensIndex;\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/DiamondLib.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { DiamondStorage } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\nimport \"./LibDiamond.sol\";\n\nimport \"../upgradeInitializers/DiamondInit.sol\";\n\nlibrary DiamondLib {\n\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\n    keccak256(\"diamond.nextblock.bitgem.app.DiamondStorage.storage\");\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport \"../interfaces/IERC173.sol\"; // for IERC173 interface\nimport \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n    event DiamondCutProposed(address indexed proposer, uint256 indexed proposalTime, uint256 executionTime);\n    event DiamondCutCancelled(address indexed canceller);\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    // Upgrade proposal struct for timelock functionality\n    struct UpgradeProposal {\n        IDiamondCut.FacetCut[] diamondCut;\n        address initAddress;\n        bytes initCalldata;\n        uint256 proposalTime;\n        bool exists;\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n        // Timelock for upgrades (in seconds)\n        uint256 upgradeTimelock;\n        // Storage for the current upgrade proposal\n        UpgradeProposal upgradeProposal;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    // Timelock constants\n    uint256 constant DEFAULT_UPGRADE_TIMELOCK = 2 days;\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    // Initialize timelock settings for upgrade proposals\n    function initializeUpgradeTimelock(uint256 _timelock) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeTimelock == 0, \"LibDiamond: Timelock already initialized\");\n        ds.upgradeTimelock = _timelock > 0 ? _timelock : DEFAULT_UPGRADE_TIMELOCK;\n    }\n\n    // Propose a diamond cut to be executed after the timelock\n    function proposeDiamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(!ds.upgradeProposal.exists, \"LibDiamond: Upgrade already proposed\");\n        require(ds.upgradeTimelock > 0, \"LibDiamond: Timelock not initialized\");\n        \n        // Create a deep copy of the diamond cut to store in the proposal\n        IDiamondCut.FacetCut[] memory diamondCutCopy = new IDiamondCut.FacetCut[](_diamondCut.length);\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            diamondCutCopy[i] = _diamondCut[i];\n            \n            // Deep copy the function selectors array\n            bytes4[] memory selectors = new bytes4[](_diamondCut[i].functionSelectors.length);\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\n                selectors[j] = _diamondCut[i].functionSelectors[j];\n            }\n            diamondCutCopy[i].functionSelectors = selectors;\n        }\n        \n        // Store the proposal\n        // Create empty array in storage first\n        delete ds.upgradeProposal.diamondCut;\n        \n        // Manually copy each element and its nested arrays to storage\n        for (uint256 i = 0; i < _diamondCut.length; i++) {\n            // Create a new struct in storage by pushing an empty element first\n            ds.upgradeProposal.diamondCut.push();\n            \n            // Now set the values for this element's fields\n            ds.upgradeProposal.diamondCut[i].facetAddress = _diamondCut[i].facetAddress;\n            ds.upgradeProposal.diamondCut[i].action = _diamondCut[i].action;\n            \n            // For the selectors array, we need to handle it separately\n            // Clear any existing selectors to ensure clean state\n            delete ds.upgradeProposal.diamondCut[i].functionSelectors;\n            \n            // Copy each selector individually\n            for (uint256 j = 0; j < _diamondCut[i].functionSelectors.length; j++) {\n                ds.upgradeProposal.diamondCut[i].functionSelectors.push(_diamondCut[i].functionSelectors[j]);\n            }\n        }\n        ds.upgradeProposal.initAddress = _init;\n        ds.upgradeProposal.initCalldata = _calldata;\n        ds.upgradeProposal.proposalTime = block.timestamp;\n        ds.upgradeProposal.exists = true;\n        \n        emit DiamondCutProposed(msg.sender, block.timestamp, block.timestamp + ds.upgradeTimelock);\n    }\n    \n    // Execute a proposed diamond cut after the timelock period\n    function executeDiamondCut() internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeProposal.exists, \"LibDiamond: No upgrade proposal exists\");\n        require(\n            block.timestamp >= ds.upgradeProposal.proposalTime + ds.upgradeTimelock,\n            \"LibDiamond: Timelock period not elapsed\"\n        );\n        \n        // Execute the diamond cut\n        diamondCut(\n            ds.upgradeProposal.diamondCut,\n            ds.upgradeProposal.initAddress,\n            ds.upgradeProposal.initCalldata\n        );\n        \n        // Reset the proposal\n        delete ds.upgradeProposal;\n    }\n    \n    // Cancel a proposed diamond cut\n    function cancelDiamondCut() internal {\n        DiamondStorage storage ds = diamondStorage();\n        require(ds.upgradeProposal.exists, \"LibDiamond: No upgrade proposal exists\");\n        \n        // Reset the proposal\n        delete ds.upgradeProposal;\n        \n        emit DiamondCutCancelled(msg.sender);\n    }\n}\n"
    },
    "contracts/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Marketplace\n * @dev A simple marketplace for buying and selling items\n */\ncontract Marketplace {\n    struct Item {\n        uint256 id;\n        string name;\n        string description;\n        uint256 price;\n        address payable seller;\n        bool sold;\n        uint256 listedAt;\n    }\n    \n    uint256 public nextItemId;\n    uint256 public marketplaceFee; // Fee in basis points (100 = 1%)\n    address public owner;\n    bool public paused;\n    \n    mapping(uint256 => Item) public items;\n    mapping(address => uint256[]) public sellerItems;\n    mapping(address => uint256) public sellerEarnings;\n    \n    event ItemListed(\n        uint256 indexed itemId,\n        string name,\n        uint256 price,\n        address indexed seller\n    );\n    \n    event ItemSold(\n        uint256 indexed itemId,\n        string name,\n        uint256 price,\n        address indexed seller,\n        address indexed buyer\n    );\n    \n    event ItemRemoved(uint256 indexed itemId, address indexed seller);\n    event EarningsWithdrawn(address indexed seller, uint256 amount);\n    event FeeUpdated(uint256 oldFee, uint256 newFee);\n    event MarketplacePaused(bool paused);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n    \n    modifier notPaused() {\n        require(!paused, \"Marketplace is paused\");\n        _;\n    }\n    \n    modifier itemExists(uint256 _itemId) {\n        require(_itemId < nextItemId, \"Item does not exist\");\n        _;\n    }\n    \n    constructor(uint256 _marketplaceFee) {\n        owner = msg.sender;\n        marketplaceFee = _marketplaceFee;\n        nextItemId = 1; // Start IDs from 1\n    }\n    \n    function listItem(\n        string memory _name,\n        string memory _description,\n        uint256 _price\n    ) public notPaused returns (uint256) {\n        require(bytes(_name).length > 0, \"Item name cannot be empty\");\n        require(_price > 0, \"Price must be greater than 0\");\n        \n        uint256 itemId = nextItemId;\n        nextItemId++;\n        \n        items[itemId] = Item({\n            id: itemId,\n            name: _name,\n            description: _description,\n            price: _price,\n            seller: payable(msg.sender),\n            sold: false,\n            listedAt: block.timestamp\n        });\n        \n        sellerItems[msg.sender].push(itemId);\n        \n        emit ItemListed(itemId, _name, _price, msg.sender);\n        return itemId;\n    }\n    \n    function buyItem(uint256 _itemId) public payable notPaused itemExists(_itemId) {\n        Item storage item = items[_itemId];\n        require(!item.sold, \"Item already sold\");\n        require(msg.sender != item.seller, \"Cannot buy your own item\");\n        require(msg.value == item.price, \"Incorrect payment amount\");\n        \n        item.sold = true;\n        \n        uint256 fee = (item.price * marketplaceFee) / 10000;\n        uint256 sellerAmount = item.price - fee;\n        \n        sellerEarnings[item.seller] += sellerAmount;\n        \n        emit ItemSold(_itemId, item.name, item.price, item.seller, msg.sender);\n    }\n    \n    function removeItem(uint256 _itemId) public itemExists(_itemId) {\n        Item storage item = items[_itemId];\n        require(msg.sender == item.seller, \"Only seller can remove item\");\n        require(!item.sold, \"Cannot remove sold item\");\n        \n        delete items[_itemId];\n        emit ItemRemoved(_itemId, msg.sender);\n    }\n    \n    function withdrawEarnings() public {\n        uint256 earnings = sellerEarnings[msg.sender];\n        require(earnings > 0, \"No earnings to withdraw\");\n        \n        sellerEarnings[msg.sender] = 0;\n        payable(msg.sender).transfer(earnings);\n        \n        emit EarningsWithdrawn(msg.sender, earnings);\n    }\n    \n    function getSellerItems(address _seller) public view returns (uint256[] memory) {\n        return sellerItems[_seller];\n    }\n    \n    function getItemCount() public view returns (uint256) {\n        return nextItemId - 1;\n    }\n    \n    // Owner functions\n    function setMarketplaceFee(uint256 _newFee) public onlyOwner {\n        require(_newFee <= 1000, \"Fee cannot exceed 10%\"); // Max 10%\n        uint256 oldFee = marketplaceFee;\n        marketplaceFee = _newFee;\n        emit FeeUpdated(oldFee, _newFee);\n    }\n    \n    function setPaused(bool _paused) public onlyOwner {\n        paused = _paused;\n        emit MarketplacePaused(_paused);\n    }\n    \n    function withdrawFees() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No fees to withdraw\");\n        payable(owner).transfer(balance);\n    }\n    \n    // Emergency function to withdraw specific earnings (owner only)\n    function emergencyWithdraw(address _seller) public onlyOwner {\n        uint256 earnings = sellerEarnings[_seller];\n        require(earnings > 0, \"No earnings for this seller\");\n        \n        sellerEarnings[_seller] = 0;\n        payable(_seller).transfer(earnings);\n        emit EarningsWithdrawn(_seller, earnings);\n    }\n}"
    },
    "contracts/SimpleStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title SimpleStorage\n * @dev Store & retrieve value in a variable\n */\ncontract SimpleStorage {\n    uint256 public storedValue;\n    address public owner;\n    \n    event ValueChanged(uint256 oldValue, uint256 newValue, address changedBy);\n    \n    constructor(uint256 _initialValue) {\n        storedValue = _initialValue;\n        owner = msg.sender;\n        emit ValueChanged(0, _initialValue, msg.sender);\n    }\n    \n    /**\n     * @dev Store value in variable\n     * @param _value value to store\n     */\n    function setValue(uint256 _value) public {\n        uint256 oldValue = storedValue;\n        storedValue = _value;\n        emit ValueChanged(oldValue, _value, msg.sender);\n    }\n    \n    /**\n     * @dev Return value \n     * @return value of 'storedValue'\n     */\n    function getValue() public view returns (uint256) {\n        return storedValue;\n    }\n    \n    /**\n     * @dev Increment the stored value by 1\n     */\n    function increment() public {\n        setValue(storedValue + 1);\n    }\n    \n    /**\n     * @dev Reset value to zero (only owner)\n     */\n    function reset() public {\n        require(msg.sender == owner, \"Only owner can reset\");\n        setValue(0);\n    }\n}"
    },
    "contracts/SimpleToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title SimpleToken\n * @dev Basic ERC20-like token implementation\n */\ncontract SimpleToken {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n    \n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Mint(address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    \n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _initialSupply\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _initialSupply * 10**_decimals;\n        owner = msg.sender;\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"Cannot transfer to zero address\");\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance\");\n        \n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0), \"Cannot transfer to zero address\");\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\n        require(allowance[_from][msg.sender] >= _value, \"Insufficient allowance\");\n        \n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function mint(address _to, uint256 _value) public {\n        require(msg.sender == owner, \"Only owner can mint\");\n        require(_to != address(0), \"Cannot mint to zero address\");\n        \n        totalSupply += _value;\n        balanceOf[_to] += _value;\n        emit Mint(_to, _value);\n        emit Transfer(address(0), _to, _value);\n    }\n    \n    function burn(uint256 _value) public {\n        require(balanceOf[msg.sender] >= _value, \"Insufficient balance to burn\");\n        \n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        emit Transfer(msg.sender, address(0), _value);\n    }\n}"
    },
    "contracts/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {        \n\n    }\n\n}\n"
    },
    "contracts/upgradeInitializers/DynamicDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ninterface IDiamondFacetInit is IERC165 {\n    function initializeFacet(\n        address _owner, \n        IDiamondCut.FacetCut memory _facet,\n        bytes calldata _calldata) external;\n}\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    function init(bytes memory initParams) external {        \n\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}